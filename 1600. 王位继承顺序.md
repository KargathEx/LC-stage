https://leetcode-cn.com/problems/throne-inheritance/

我的做法：
```cpp


class treeNode {
public:
  treeNode(string name_) :name(name_) {};
  string name;
  vector<treeNode*> child;
};
class ThroneInheritance {
  treeNode* king;
public:
  ThroneInheritance(string kingName) {
    king = new treeNode(kingName); 
  }
  treeNode* find(treeNode* source, string target)
  {
    if (!source)return nullptr;
    if (source->name == target)return source;
    for (auto i : source->child)
    {
      auto it = find(i, target);
      if (it)return it;
    }
    return nullptr;
  }
  void birth(string parentName, string childName) {
    //有人出生，就给数组中对应的节点加一个child.
    auto it = find(king, parentName);
    if (it)it->child.push_back(new treeNode(childName));
  }

  void delete_name(treeNode* r, string name)
  {
    if (!king)return;
    if (r->name == name)r->name = "";//国王之死
    if (r->child.empty())return;
    for (auto i : r->child)
    {
      if (i->name == name)
        //人死，他的孩子们应该保持原来的优先度，而不是跟他一起被无视，
        //把一堆孩子搬到父亲的座位上太麻烦了，标记string ""代表人已经死，
        //这样其孩子就不用动了。
        i->name = ""; 
      else
        delete_name(i, name);
    }
  }
  void death(string name) {
    delete_name(king,name);
  }
  void order(treeNode* source, vector<string>& out)
  {
    if (!source)return;
    if (source->name != "") //死了的不加入结果，这样就不需要动原来的结构了。
      out.push_back(source->name);
    if (source->child.empty())return ;
    for (auto i : source->child)
      order(i, out);
    return;
  }
  vector<string> getInheritanceOrder() {
    vector<string> out;
    order(king,out);
    return out;
  }
};


```
然后跪在了47 / 49 

如何优化这个过程，就像bit翻转一样，既然每次函数调用都只会维护一点点，是否可以找合适的结构？
比如，birth()只会添加东西，它会影响每个节点，以及遍历结果里中间需要插入东西。
death()会删掉一个值，对于结果序列，只会少一个东西，
getInheritanceOrder()  每次都会遍历所有节点..
看到一个做法是，HashTable + DFS，映射父子节点。
每个father和child list是这样unordered_map<string,vector<string>> 这样？
遍历的时候就从king开始，每次修改也只需要动其中一个. ?
取结果的时候还不是得全都来一遍?

hua的做法跟我想到的一模一样：

```cpp
// Author: Huahua
class ThroneInheritance {
public:
  ThroneInheritance(string kingName) : king_(kingName) {
    m_[kingName] = {};
  }
  void birth(string parentName, string childName) {
    m_[parentName].push_back(childName);
  }
  void death(string name) {
    dead_.insert(name);
  }
  vector<string> getInheritanceOrder() {
    vector<string> ans;
    function<void(const string&)> dfs = [&](const string& name) {
      if (!dead_.count(name)) ans.push_back(name);      //它count和我直接改成""有啥区别?
      for (const string& child : m_[name]) dfs(child);    //这不一样是dfs?每次找order都会把所有节点都过一遍.. 人家没有节点，hashmap虽然比数组拉跨，至少访问速度比内存里一堆new出来的treeNode快..?
    };
    dfs(king_);
    return ans;
  }
private:
  string king_;
  unordered_map<string, vector<string>> m_; // parent -> list[children]
  unordered_set<string> dead_;
};
```
他的很容易想到，但是我不知道自己的时间复杂度相比于它慢在哪里。
