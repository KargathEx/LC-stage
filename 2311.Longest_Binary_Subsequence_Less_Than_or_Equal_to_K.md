
https://leetcode.cn/contest/weekly-contest-298/problems/longest-binary-subsequence-less-than-or-equal-to-k/

给你一个二进制字符串 `s` 和一个正整数 `k` 。

请你返回 `s` 的 **最长** 子序列，且该子序列对应的 **二进制** 数字小于等于 `k` 。

注意：

- 子序列可以有 **前导 0** 。
- 空字符串视为 `0` 。
- **子序列** 是指从一个字符串中删除零个或者多个字符后，不改变顺序得到的剩余字符序列。

**示例 1：**

```
输入：s = "1001010", k = 5
输出：5
解释：s 中小于等于 5 的最长子序列是 "00010" ，对应的十进制数字是 2 。
注意 "00100" 和 "00101" 也是可行的最长子序列，十进制分别对应 4 和 5 。
最长子序列的长度为 5 ，所以返回 5 。
```

**示例 2：**

```
输入：s = "00101001", k = 1
输出：6
解释："000001" 是 s 中小于等于 1 的最长子序列，对应的十进制数字是 1 。
最长子序列的长度为 6 ，所以返回 6 。
```

**提示：**

- `1 <= s.length <= 1000`
- `s[i]` 要么是 `'0'` ，要么是 `'1'` 。
- `1 <= k <= 109`

思路：

题目要求是合法的子序列，且字符串长度为`1 <= s.length <= 1000` ，则可以考虑On^2的做法。  
因为要求子序列对应的二进制形式翻译成十进制不得大于k,所以尝试枚举这些。  
前导0不会影响值的大小，只考虑valid的部分，尝试从右往左枚举每一个valid substr的end位置，从该位置向前，到某一个1为止(再往前的就都只取值为0的作为前导0的一部分)  
这样就相当于枚举所有的end和len,恰好On^2.  
但是每个位置可能是1或者0,有时候对于subseq中间的部分，是否选择一个1至关重要，比如：  
1000101001001，末尾的1001部分代表的是9，再往前一位的1001001，如果去掉中间的1，代表的是65.  
如果加上那个1，值为65+8=73,如果k为72,则加上这个中间的1就会超出。  
但是在初次遇到1的时候，无法知道到底该不该加这个1，这就用到了回溯，枚举所有的可能性。  
可是无论是回溯还是dp来记忆每一个1的位置是否选择的多种状态，时间复杂度都会变成Exponential 的，这就完了。  
所以我不会了。  
  
二题废物敬上。 
