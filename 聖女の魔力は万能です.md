[问题来源](https://leetcode.cn/contest/weekly-contest-302/problems/query-kth-smallest-trimmed-number/) 
给你一个下标从 **0** 开始的字符串数组 `nums` ，其中每个字符串 **长度相等** 且只包含数字。

再给你一个下标从 **0** 开始的二维整数数组 `queries` ，其中 `queries[i] = [ki, trimi]` 。对于每个 `queries[i]` ，你需要：

- 将 `nums` 中每个数字 **裁剪** 到剩下 **最右边** `trimi` 个数位。
- 在裁剪过后的数字中，找到 `nums` 中第 `ki` 小数字对应的 **下标** 。如果两个裁剪后数字一样大，那么下标 **更小** 的数字视为更小的数字。
- 将 `nums` 中每个数字恢复到原本字符串。

请你返回一个长度与 `queries` 相等的数组 `answer`，其中 `answer[i]`是第 `i` 次查询的结果。

**提示：**

- 裁剪到剩下 `x` 个数位的意思是不断删除最左边的数位，直到剩下 `x` 个数位。
- `nums` 中的字符串可能会有前导 0 。

**示例 1：**

```
输入：nums = ["102","473","251","814"], queries = [[1,1],[2,3],[4,2],[1,2]]
输出：[2,2,1,0]
解释：
1. 裁剪到只剩 1 个数位后，nums = ["2","3","1","4"] 。最小的数字是 1 ，下标为 2 。
2. 裁剪到剩 3 个数位后，nums 没有变化。第 2 小的数字是 251 ，下标为 2 。
3. 裁剪到剩 2 个数位后，nums = ["02","73","51","14"] 。第 4 小的数字是 73 ，下标为 1 。
4. 裁剪到剩 2 个数位后，最小数字是 2 ，下标为 0 。
   注意，裁剪后数字 "02" 值为 2 。
```

**示例 2：**

```
输入：nums = ["24","37","96","04"], queries = [[2,1],[2,2]]
输出：[3,0]
解释：
1. 裁剪到剩 1 个数位，nums = ["4","7","6","4"] 。第 2 小的数字是 4 ，下标为 3 。
   有两个 4 ，下标为 0 的 4 视为小于下标为 3 的 4 。
2. 裁剪到剩 2 个数位，nums 不变。第二小的数字是 24 ，下标为 0 。
```

**提示：**

- `1 <= nums.length <= 100`
- `1 <= nums[i].length <= 100`
- `nums[i]` 只包含数字。
- 所有 `nums[i].length` 的长度 **相同** 。
- `1 <= queries.length <= 100`
- `queries[i].length == 2`
- `1 <= ki <= nums.length`
- `1 <= trimi <= nums[0].length`

------

## 思路

照着题目的要求写了  

```cpp
class Solution {
public:
  vector<int> smallestTrimmedNumbers(vector<string>& n, vector<vector<int>>& q) {
    vector<int> r;
    if (n.empty() || q.empty())return {};
    for (int i = 0; i < q.size(); ++i)
    {
      int kth = q[i][0];
      int trim = q[i][1];
      vector<pair<unsigned long long, int>> t;
      if (n[0].size() > trim)
        for (int j = 0; j < n.size(); ++j)
          t.push_back(make_pair(stoull(n[j].substr(n[j].size() - trim)), j)); 
      //sto*系列不可用，数字太大(什么时候不可用?)
      else
        for (int j = 0; j < n.size(); ++j)
          t.push_back(make_pair(stoull(n[j]), j));
      sort(all(t));
      r.push_back(t[kth - 1].second);
    }
    return r;
  }
};
```

想了一圈没有比`stoull`更大的了，要用`stringstream ss(s) >> int num` 那一套，流出来的数字还是装不下。  
二十分钟过去了，还是没搞定。  
事后在结果第一页点开五六个全都是`python  `

```python
from math import gcd
class Solution:
    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:
        g = 0
        for num in numsDivide:
            g = gcd(g, num)
        nums.sort()
        for i in range(len(nums)):
            if g % nums[i] == 0:
                return i
        return -1
```

难道我真的要转`py`了吗...   
最后看到了这个！  

```cpp

vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& q) {
  vector<int> res(q.size());
  int x = nums[0].size();
  for (int i = 0; i < q.size(); ++i) {
    vector<pair<string, int>> tmp(nums.size());
    for (int j = 0; j < nums.size(); ++j) {
      tmp[j] = { nums[j].substr(max(0, x - q[i][1])), j };
    }
    sort(tmp.begin(), tmp.end());
    res[i] = tmp[q[i][0] - 1].second;
  }
  return res;
}
```

贴一篇十年前的[旧文](https://coolshell.cn/articles/6548.html)   
少折腾语言，多攒技巧，没有什么是别人做的到而你做不到的。  

2022/7/17 ,二题废物留。