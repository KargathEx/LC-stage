有 `n` 个朋友在举办一个派对，这些朋友从 `0` 到 `n - 1` 编号。派对里有 **无数** 张椅子，编号为 `0` 到 `infinity` 。当一个朋友到达派对时，他会占据 **编号最小** 且未被占据的椅子。

- 比方说，当一个朋友到达时，如果椅子 `0` ，`1` 和 `5` 被占据了，那么他会占据 `2` 号椅子。

当一个朋友离开派对时，他的椅子会立刻变成未占据状态。如果同一时刻有另一个朋友到达，可以立即占据这张椅子。

给你一个下标从 **0** 开始的二维整数数组 `times` ，其中 `times[i] = [arrivali, leavingi]` 表示第 `i` 个朋友到达和离开的时刻，同时给你一个整数 `targetFriend` 。所有到达时间 **互不相同** 。

请你返回编号为 `targetFriend` 的朋友占据的 **椅子编号** 。

**示例 1：**

```
输入：times = [[1,4],[2,3],[4,6]], targetFriend = 1
输出：1
解释：
- 朋友 0 时刻 1 到达，占据椅子 0 。
- 朋友 1 时刻 2 到达，占据椅子 1 。
- 朋友 1 时刻 3 离开，椅子 1 变成未占据。
- 朋友 0 时刻 4 离开，椅子 0 变成未占据。
- 朋友 2 时刻 4 到达，占据椅子 0 。
朋友 1 占据椅子 1 ，所以返回 1 。
```

**示例 2：**

```
输入：times = [[3,10],[1,5],[2,6]], targetFriend = 0
输出：2
解释：
- 朋友 1 时刻 1 到达，占据椅子 0 。
- 朋友 2 时刻 2 到达，占据椅子 1 。
- 朋友 0 时刻 3 到达，占据椅子 2 。
- 朋友 1 时刻 5 离开，椅子 0 变成未占据。
- 朋友 2 时刻 6 离开，椅子 1 变成未占据。
- 朋友 0 时刻 10 离开，椅子 2 变成未占据。
朋友 0 占据椅子 2 ，所以返回 2 。
```

 

**提示：**

- `n == times.length`
- `2 <= n <= 104`
- `times[i].length == 2`
- `1 <= arrivali < leavingi <= 105`
- `0 <= targetFriend <= n - 1`
- 每个 `arrivali` 时刻 **互不相同** 。

### 思   

对[排序，塞进优先队列里]和chair_index.
如果队列为空则增加椅子编号且塞入当前。  
如果最早一个离开的人的时间大于当前找座位的人，则搬来新椅子。  
否则让新人直接做到已经空出的椅子上。    
排序之前给每个人加一个index,之后赋值时候根据它来找到该人需要把答案塞进的数组里的位置。

```cpp

class Solution {
public:
  int smallestChair(vector<vector<int>>& p, int t) {
    vector<pair<int,vector<int>>> n;
    for (int i = 0; i < p.size(); ++i)
      n.push_back(make_pair(i, p[i]));
    sort(begin(n), end(n), [&](pair<int, vector<int>> a, pair<int, vector<int>> b) {return a.second[0] < b.second[0]; });
    dbg(n);
    priority_queue<pair<int, int>> pq;    //end,chair_index
    vector<int> res(p.size(),0);
    int chair = 0;
    for (int i = 0; i < n.size(); ++i)
    {
      if (pq.empty()) {
        res[n[i].first]=chair;
        pq.push(make_pair(n[i].second[1], chair)); continue;
      }
      auto top = pq.top();
      if (top.first <= n[i].second[0])  //前n个有空余 应该是可以的...
      {
        pq.pop();
        res[n[i].first]=top.second; //新人坐上这个椅子
        top.first = n[i].second[1];
        pq.push(top);
        continue;
      }
      if (top.first > n[i].second[0])  //没有空余，搬来新椅子
      {
        ++chair;
        res[n[i].first]=chair;
        pq.push(make_pair(n[i].second[1], chair));
      }
    }
    dbg(res);
    return res[t];
  }
};
```

通过**43 / 60** 个测试用例。  
原因不详。

问题来源: https://leetcode.cn/classic/problems//description/
