『 暴力、字符串编码、Z函数 』三种解法详解


### 解题思路

**方法一：暴力匹配 + 二分**

从后往前枚举 $s_m$ （$s_m$ 表示长度为 $i$ 的字符串，$s=s_n$），先进行简单的判断：
* 若 $s_m[0]  \neq s[0]$，则 $s_m$ 与 $s$ 不会存在公共前缀，得分为 $0$； `（大部分字符串不存在公共前缀，此举可加速运算）`
* 若 $s_m[0]  = s[0]$，可进一步基于 **二分搜索** 找到最长的公共前缀：
    *  二分搜索初始化 $left = 0, right = m+1, mid = (left+right) // 2$
    * 判断 $s_m$ 的前 $mid$ 项是否与 $s$ 的前 $mid$ 项一样：
        * 若 $s[n-m:n-m+mid]=s[:mid]$，尝试扩大搜索范围：$left = mid+1$； `（往右搜索）`
        * 否则，缩小搜索范围 $right = mid$；
    * 最终，$s_m$ 的得分为 $left-1$。`（二分搜索往右搜索的特性）`


>⚠️ 这种方法在匹配字符串时过于暴力，在测试用例中卡在了第 $140$ 个用例上，即 $100000$ 个 `a`。
充分发挥《面向测试用例的编程》精神，对于该用例特殊处理即可暴力通过全部143个用例。🤣

![contest.png](https://pic.leetcode-cn.com/1649049030-rCjLfq-contest.png){:width=400}

&nbsp;



#### 代码

```Python3 []
class Solution:
    def sumScores(self, s: str) -> int:
        
        n = len(s)
        if len(set(s)) == 1:        # 面向测试用例：100000个'a'
            return n * (n + 1) // 2
        
        ans = n                     # 字符串s本身满足要求
        for m in range(1, n):       # 枚举si的长度m
            if s[n-m] != s[0]:      # 快速简单判断：s[n-m]是长度为m的后缀字符串的首字母
                continue
            left, right = 0, m + 1  # 二分模板
            while left < right:
                mid = (left + right) // 2
                if s[:mid] == s[n-m:n-m+mid]:
                    left = mid + 1      # 若成立，尝试增大字符长度: 往右查找【bisect_right】
                else:
                    right = mid
            
            ans += left-1     # bisect_right搜索特性：left此时并不可行，应返回left-1
        
        return ans
```


&nbsp;

---

**方法二：字符串编码  + 二分**

方法一在字符串匹配上浪费了太多时间，更为通用的方法为 **字符串编码**。

字符串编码的理论基础可参考题目 **1392. 最长快乐前缀**：

| 题号 |  题解 | 难度 |
| :-----| :---- | :----: |
| 1392. 最长快乐前缀 |  [官方题解链接](https://leetcode-cn.com/problems/longest-happy-prefix/solution/zui-chang-kuai-le-qian-zhui-by-leetcode-solution) | 困难 |

&nbsp;
一般地，一个字符串 $s$ 的编码值计算公式如下：

$$encode(s) = \sum_{i=0}^{|s|-1} s[i] * \textit{base}^{|s|-i-1},$$
其中 $base$ 为选定的进制单位。例如，本题中 $s$ 仅包含 $26$ 个小写字母，因此 $base$ 可取一个大于 $26$ 的数（如 $base=31$）。

> 👀 两个字符串 $s$ 和 $t$ 相等，当且仅当它们的长度相等且编码值相等：
    $len(s)=len(t)\ 且\ encode(s) = encode(t)$

>  ⚠️ 需要注意的是本题在编码字符串时与 **1392. 最长快乐前缀** 的官方题解略有不同，  字符$s[i]$ 的编码不能简单地以 $s[i]-97$ 表示，例如这会导致 $encode('ab') = encode('b')$ （在后面基于 $prefix$ 计算区间编码时会遇到）；可以以 $s[i]-97+1$ 来表示，避免前导编码 $0$ 的影响。


&nbsp;
接下来问题就转化为了如何预处理出不同长度字符的编码表示。


对于以 $s[i]$ 结尾的前缀字符串 $s[0,...,i]$，我们可以预处理出其编码值，记为 $prefix[i+1]$。特别地，$prefix[0]=0$。

容易得到以下递推关系：
$$prefix[i+1] = prefix[i] * base + encode(s[i])\ .$$

基于前缀编码 $prefix$，可快速得到任一区间字符的编码表示：
> 举个例子，对于字符串 $'b\textcolor{red}{ab}aab'$ 如何得到中间字符 $'\textcolor{red}{ab}'$ 的编码表示：
> $$encode('\textcolor{red}{ab}') = encode('b\textcolor{red}{ab}')- encode('b')  \times base^{2} \ .$$

$$encode(s[left,...,right]) = prefix[right+1]-prefix[left] \times base^{right-left+1}\ .$$

> 为了加速运算，上式中 $base^{right-left+1}$ 这一项可以预处理出一个表示 $base$ 进制的幂次数组 $mul$，满足
> $$mul[i] = base^{i}$$


&nbsp;

在实际编码中，当字符串的长度很长时，对应的哈希编码值也会很大，甚至会超出整数类型的范围。对此，一般的解决方法是对字符的编码值进行取模（$MOD$），使其保持在整数类型的范围之内。

> ⚠️ 需要注意的是，取模可能会带来哈希碰撞。本题解未考虑哈希碰撞的发生。实际中为了减小碰撞的可能，可采用双哈希等策略。例如，使用两套进制和模的组合来对字符串进行编码，只有两套编码值都相同时，我们才认为字符串相同。相关做法可参考题目 [1044. 最长重复子串](https://leetcode-cn.com/problems/longest-duplicate-substring/) 的 [官方题解](https://leetcode-cn.com/problems/longest-duplicate-substring/solution/zui-chang-zhong-fu-zi-chuan-by-leetcode-0i9rd/)。

---
**拓展：**

字符串哈希编码是处理一系列字符串匹配问题的通用方法，掌握模板可解决如下问题：

| 题号 |  题解 | 难度 |
| :-----| :---- | :----: |
| [28. 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/) |  [『 字符串哈希 、KMP』掌握模板，团灭一众字符匹配问题](https://leetcode-cn.com/problems/implement-strstr/solution/zi-fu-chuan-ha-xi-kmp-shuang-jie-by-flix-mlq1/) | （并不）简单 |
| [796. 旋转字符串](https://leetcode-cn.com/problems/rotate-string/) |  [『 字符串哈希 、KMP』掌握模板，团灭一众字符匹配问题](https://leetcode-cn.com/problems/rotate-string/solution/by-flix-eadi/) | （并不）简单 |
| [214. 最短回文串](https://leetcode-cn.com/problems/shortest-palindrome/) |  [『 字符串哈希、KMP 』掌握模板，团灭一众字符匹配问题](https://leetcode-cn.com/problems/shortest-palindrome/solution/by-flix-be4y/) | 困难 |
| （接近本题）[1044. 最长重复子串](https://leetcode-cn.com/problems/longest-duplicate-substring/) |  [『 字符串双哈希 + 二分 』掌握模板，团灭一众字符匹配问题](https://leetcode-cn.com/problems/longest-duplicate-substring/solution/by-flix-fs5k/) | 困难 |
| （接近本题）[1316. 不同的循环子字符串](https://leetcode-cn.com/problems/distinct-echo-substrings/) |   [『 字符串哈希、KMP 』掌握模板，团灭一众字符匹配问题](https://leetcode-cn.com/problems/distinct-echo-substrings/solution/by-flix-zsuj/) | 困难 |
| [1392. 最长快乐前缀](https://leetcode-cn.com/problems/longest-happy-prefix/) |  [『 字符串哈希、KMP 』掌握模板，快乐其实很简单 🤣](https://leetcode-cn.com/problems/longest-happy-prefix/solution/by-flix-k4p3/) | 困难 |
|（本题） [2223. 构造字符串的总得分和](https://leetcode-cn.com/problems/sum-of-scores-of-built-strings/) |   [『 暴力、字符串编码、Z函数 』三种解法详解](https://leetcode-cn.com/problems/sum-of-scores-of-built-strings/solution/by-flix-icgi/) | 困难 |

---

&nbsp;

#### 代码

```Python3 []
class Solution:
    def sumScores(self, s: str) -> int:
        
        MOD = 10**9+7
        base = 31       # s仅包含小写字母，base可取31
        
        '''字符编码函数'''
        def encode(ch):
            return ord(ch) - ord('a') + 1

        n = len(s)
        # 预处理出前缀字符串的哈希值 和 base进制的幂
        prefix = [0] * (n+1)    # prefix[i]: 字符串s[0:i]的哈希值
        mul = [1] * (n+1)       # mul[i]: base ** i
        for i in range(1, n+1):
            prefix[i] = ( prefix[i-1] * base + encode(s[i-1]) ) % MOD
            mul[i] = mul[i-1] * base % MOD
        
        ans = n                     # 字符串s本身满足要求
        for m in range(1, n):       # 枚举si的长度m
            if s[n-m] != s[0]:      # 快速简单判断：s[n-m]是长度为m的后缀字符串的首字母
                continue
            left, right = 0, m + 1  # 二分模板
            while left < right:
                mid = (left + right) // 2
                hash_val = ( prefix[n-m+mid] - prefix[n-m] * mul[mid] % MOD + MOD ) % MOD
                if hash_val == prefix[mid]:
                    left = mid + 1      # 若成立，尝试增大字符长度: 往右查找【bisect_right】
                else:
                    right = mid
            
            ans += left-1     # bisect_right搜索特性：left此时并不可行，应返回left-1
        
        return ans
```



&nbsp;

---

**方法三：Z函数（扩展 KMP）**

本题恰是 Z函数（又称 扩展 KMP）的应用题。
相关介绍可参考：
| 来源 |  链接 | 案例展示 |
| :-----| :---- | :----: |
|OI Wiki - Z 函数（扩展 KMP） |https://oi-wiki.org/string/z-func/ | https://personal.utdallas.edu/~besp/demo/John2010/z-algorithm.htm |


定义函数 $z[i]$ 表示 $s$ 和 $s[i,..,n-1]$（以 $s[i]$ 开头的后缀）的最长公共前缀（LCP）的长度。枚举 $i$ 即可计算每一步的得分。

&nbsp;


```Python3 []
class Solution:
    def sumScores(self, s: str) -> int:
        
        n = len(s)
        z = [0] * n             # z函数
        left, right = 0, 0      # 匹配段（Z-box）的闭区间
        
        ans = n                 # 加上s自身长度n
        for i in range(1, n):   # 从下标1开始计算z函数
            if i <= right and z[i - left] < right - i + 1:  # 当前位置处于Z-box中，且处于可确定的匹配范围内（不在Z-box边缘），则无需重复计算而直接得出z[i]
                z[i] = z[i - left]
            else:
                z[i] = max(0, right - i + 1)    # （上一个）Z-box的右端可能位于i的左侧
                while i + z[i] < n and s[z[i]] == s[i + z[i]]:  # 暴力匹配
                    z[i] += 1                   # 公共前缀+1
            
            if i + z[i] - 1 > right:            # Z-box区间需更新
                left, right = i, i + z[i] - 1
            
            ans += z[i]     # z[i]即是s[i:n]与s的最长公众前缀的长度
        
        return ans
```


