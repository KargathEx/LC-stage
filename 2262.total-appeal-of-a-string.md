在肝了一下午原神把升到50级之后，七点钟开始看[这个问题](https://leetcode.cn/contest/weekly-contest-291/problems/total-appeal-of-a-string/)。  


字符串的 **引力** 定义为：字符串中 **不同** 字符的数量。

- 例如，`"abbca"` 的引力为 `3` ，因为其中有 `3` 个不同字符 `'a'`、`'b'` 和 `'c'` 。

给你一个字符串 `s` ，返回 **其所有子字符串的总引力** **。**

**子字符串** 定义为：字符串中的一个连续字符序列。

**示例 1：**

```
输入：s = "abbca"
输出：28
解释："abbca" 的子字符串有：
- 长度为 1 的子字符串："a"、"b"、"b"、"c"、"a" 的引力分别为 1、1、1、1、1，总和为 5 。
- 长度为 2 的子字符串："ab"、"bb"、"bc"、"ca" 的引力分别为 2、1、2、2 ，总和为 7 。
- 长度为 3 的子字符串："abb"、"bbc"、"bca" 的引力分别为 2、2、3 ，总和为 7 。
- 长度为 4 的子字符串："abbc"、"bbca" 的引力分别为 3、3 ，总和为 6 。
- 长度为 5 的子字符串："abbca" 的引力为 3 ，总和为 3 。
引力总和为 5 + 7 + 7 + 6 + 3 = 28 。
```

**示例 2：**

```
输入：s = "code"
输出：20
解释："code" 的子字符串有：
- 长度为 1 的子字符串："c"、"o"、"d"、"e" 的引力分别为 1、1、1、1 ，总和为 4 。
- 长度为 2 的子字符串："co"、"od"、"de" 的引力分别为 2、2、2 ，总和为 6 。
- 长度为 3 的子字符串："cod"、"ode" 的引力分别为 3、3 ，总和为 6 。
- 长度为 4 的子字符串："code" 的引力为 4 ，总和为 4 。
引力总和为 4 + 6 + 6 + 4 = 20 。
```

**提示：**

- `1 <= s.length <= 105`
- `s` 由小写英文字母组成

想法如下，遍历一下字符串，记录每个字符的首次出现位置。  
因为位置是unique的，所以map以postion为key,char为value是可以的，且这样可以用来找对于给定的位置p,最接近它的position是啥。    
遍历每一个作为开头的子串，需要On时间  
在其中查找每个大于当前位置的某字符首次出现的位置，然后看一下该字符是否已出现于滑动窗口中，不存在就加入，且从该位置继续往后找。  
具体操作在代码注释中，遇到的问题也在注释中。  

```cpp

class Solution {
  unordered_map<string, long long> m;
public:
  long long appealSum(string s) {
    map<int, char> occur; //pos as key ,for binary search to find the nearest
    for (char ch = 'a'; ch <= 'z'; ++ch)
    {
      auto pos = s.find_first_of(ch);
      if (pos != string::npos)occur[pos] = ch;
    }
    long long res = 0;
    set<int> exist; //滑动窗口中包含字符的个数

    //遍历所有子串？ 只以每一个值作为开始位置，计算从它往后形成的各个子串的字符串权重值。
    //一个想法是，记录不存在于字符串里的字符的首次出现位置，直接从当前位置跳到那里，中间经过的其他字符都是已经出现在滑动窗口里的了，所以结果直接加上"跳动的步长*当前滑动窗口里字符的个数"即可。

    //所以实现如下:
    for (int i = 0; i < s.size(); ++i) //每一个开始位置
    {
      exist.insert(s[i]);//插入当前子串的第一个字符

      //在数组里找最接近且大于当前位置的位置，然后看一下它的字符是否已经出现在滑动窗口中，如果没有就加进来，且如上计算。
      //map里的pos是有序的，所以可以对它执行二分查找。
      while (i < s.size()) {  //当前字串没有扩展到右边界就可以一直进行。
        auto next = std::upper_bound(begin(occur), end(occur), i);  //找到所有字符里首次出现位置大于当前位置的
        if (next == occur.end())break;  //如果找不到就说明剩下的都是(当前字符了? 混乱)
        if (exist.find(next->second) == exist.end()) //如果该字符不存在于子串，则加入
          exist.insert(next->second);

        auto diff = next->first - i;  //记录中间跳过了几个子串
        
        i = next->first;    //无论它存在与否都以其为开始位置来找下一个可能新出现的字符.

        res += diff * exist.size();
      }
      //但是这样存在问题:
      //occur需要记住的是在当前位置之后，每一个字符第一次出现的位置，能用来查询"它之前是否存在"比如
      //abcc|ddaa|dfg 
      // 这个子串加入a的时候需要a在当前出现的位置，而非之前出现过的位置，因为dd dda ddaa是三个不同的子串。
      
      // 在最外层的循环里每次都更新它 ? ? 应该可以，把每个字符出现的所有位置都存下来，用掉一个的时候立马换上下一个.
      //但是这仍然没法保证枚举每个开始过程的时候，m里保存的都是大于当前位置的第一个位置。
      //要么得在for循环里面重建这个map(重建过程需要n,外面的for是n,又超时了..)

    }
    return res;
  }
};
```

`知道当前有哪些字符还没出现`  
`跳到那些里面的最近的一个下标 `  

这俩操作该怎么进行,不知道...