题目:https://leetcode-cn.com/problems/count-number-of-texts/
思路：  

&nbsp; &nbsp;  解释一下decode()里的for部分。  
&nbsp; &nbsp; 对于2222 的22|22情况，会被两次递归所覆盖，所以不需要什么“把子串分割成不同的长度，计算其各自的组合数然后取积。”  

&nbsp; &nbsp; 我觉得它与题解区一堆dp是一样的，不知道错在哪。
&nbsp; &nbsp; 而且这题只给一个例子，第二个就直接`2222222222222...22`也太混蛋了吧。  

&nbsp; &nbsp; 如何画一匹马.jpg  

&nbsp; &nbsp; 以后你们是不是就连测试例子都不给了，题库枯竭了就开始在其他地方加大难度，一点点脱下外套露出codeforce的阴毛？

&nbsp; &nbsp; 我知道dp可解，我就是想知道自己到底错在哪了。  

&nbsp; &nbsp; go的`var f = [mx + 1]int{1, 1, 2, 4}`真他妈傻逼。


```cpp
class Solution {
  const long long mod = 1000000007;
  unordered_map<string, long long> memo;
  //len为当前字符串最大解码可用子串长度.
  long long decode(string str, int len)
  {
    if (str.empty())return 0;
    if (str.size() == 1)return 1;
    if (memo.find(str) != memo.end())return memo[str];
    long long cnt = 1;
    for (int i = 1; i < len; ++i)
      cnt += decode(str.substr(i), len);
    cnt = cnt % mod;
    memo[str] = cnt;
    return cnt;
  }
public:
  long long countTexts(string s) {
    string curr(1, s[0]);
    long long res = 1;
    for (int i = 1; i < s.size(); ++i)
    {
      if (s[i] == curr.back()) {
        curr.push_back(s[i]);
      }
      else {
        int len = 0;
        if (curr.back() == '7' || curr.back() == '9')len = 4;
        else len = 3;
        res *= decode(curr, len);
        res %= mod;
        curr = string(1, s[i]);
      }
    }
    int len = 0;
    if (curr.back() == '7' || curr.back() == '9')len = 4;
    else len = 3;
    res *= decode(curr,len);
    res %= mod;
    return res;
  }
};
```
