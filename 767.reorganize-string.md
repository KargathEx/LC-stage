Q:https://leetcode.cn/classic/problems/reorganize-string/description/ 

给定一个字符串 `s` ，检查是否能重新排布其中的字母，使得两相邻的字符不同。

返回 *`s` 的任意可能的重新排列。若不可行，返回空字符串 `""`* 。

**示例 1:**

```
输入: s = "aab"
输出: "aba"
```

**示例 2:**

```
输入: s = "aaab"
输出: ""
```

 

**提示:**

- `1 <= s.length <= 500`
- `s` 只包含小写字母

### 思路

首先按照个数多少从多到少排序，然后交换之。

```cpp

#define ice
#ifdef ice
typedef long long ll;
typedef vector<int> vi;
typedef vector<vi> vii;
typedef vector<string> vs;
typedef vector<vs> vss;
#define all(c) c.begin(), c.end()
#define rall(c) c.rbegin(), c.rend()
//const int dx[4]{ 1,0,-1,0 }, dy[4]{ 0,1,0,-1 };
#define sz(a) int((a).size())
#define pb push_back
template<typename T> void un(T& n) { sort(all(n)); n.erase(std::unique(n.begin(), n.end()), n.end()); }
template<typename T>set<typename T::value_type> to_set(T t) { return set(t.begin(), t.end()); }
template<typename T>vector<typename T::value_type> set_to(T input) { vector<typename T::value_type> output; std::copy(input.begin(), input.end(), std::back_inserter(output)); return output; }
vector<int> get_insect(vector<int>n1, vector<int> n2) { vector<int> res; set_intersection(all(n1), all(n2), inserter(res, res.end())); return res; }
template<typename T>auto clear(queue<T>& q) { std::queue<T>empty; std::swap(q, empty); }
template<class T> using pqg = priority_queue<T, vector<T>, greater<T>>;
vector<string> split(string s, string delimiter = " ") {
  std::stringstream stringStream(s);
  std::string line;
  vector<string> wordVector;
  while (std::getline(stringStream, line))
  {
    std::size_t prev = 0, pos;
    while ((pos = line.find_first_of(delimiter, prev)) != std::string::npos)
    {
      if (pos > prev)
        wordVector.push_back(line.substr(prev, pos - prev));
      prev = pos + 1;
    }
    if (prev < line.length())
      wordVector.push_back(line.substr(prev, std::string::npos));
  }
  return wordVector;
}
#define D(x) cout << #x << " : " << x << endl;
#define ed cout << endl;
//#define  sw cout<<res<<endl<<l<<" "<<r<<endl<<endl; //滑动窗口debug用。
//#define rt  return res;

#endif
//#define D(x);
class Solution {
  string sortByCnt(string s)  //待会存起来！加个模板处理vec
  {
    unordered_map<char, int> c;
    for (auto i : s)c[i]++;
    vector<pair<int, int>> sorted;
    for (auto [val, cnt] : c)
      sorted.push_back(make_pair(cnt, val));
    sort(all(sorted));
    string res;
    for (auto [cnt, val] : sorted)
      res += string(cnt, val);
    reverse(all(res));
    return res;
  }
public:
  string reorganizeString(string s) {
    s = sortByCnt(s);
    D(s);
    vector<int> c(26, 0);
    for (auto i : s) c[i - 'a']++;
    for (auto i : c) {
      if (s.size() % 2 == 1 && i > s.size() / 2 + 1)return "";
      if (s.size() % 2 == 0 && i > s.size() / 2)return "";
    }
    //下面干正事了，swap!
    if (s.size() % 2 == 0) {
      for (int i = 1; i <= s.size() / 2; i += 2){
        swap(s[i], s[s.size() - 1 - i]);  //应该交换的是那啥没错吧..   偶数时候才能这么交换..
        D(s);
      }
    }
    else
    {
      for (int i = 1; i <= s.size() / 2; i += 2)
        if (i < s[s.size() - 2 - i])
          swap(s[i], s[s.size() - i]);  //这里怎么交换呢?
    }
    return s;
  }
};
```

对于例子 `ogccckcwmbmxtsbmozli` 输出为`ciclmtmxobbzowmsckcg` 中间的两个b没有拆开，待微调。

> "ciclmtmxobbzowmsckcg"
>  12345678900123456789
>  刚好是挨着的俩，没有被正确处理。
>
> ccccmmmoo bb zxwtslkig
> 123456789 00 123456789

