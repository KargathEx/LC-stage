https://leetcode.cn/problems/maximum-candies-allocated-to-k-children/

思路：

二分[1,max_in_array] 来找合适的数字。  
对于每个猜测的数字，计算数组中可以分裂出来多少个这样的值，取其最大的。

```cpp

class Solution {
public:
  int maximumCandies(vector<int>& n, long long k) {
    //dbg(n);
    //dbg(k);
    if (accumulate(begin(n), end(n), 0LL) < k)return 0; //无法构成有效解.

    sort(begin(n), end(n));
    int prev_valid = 0; //当二分函数执行到最下面的l时候..`可能`代表该值是invalid的，此时返回-1,并且从记录的前一个可用值里获得结果。

    auto binarySearch = [&](int l, int r) ->int {
      while (l < r) {
        int m = l + (r - l) / 2;
        int cnt = 0;
        for (auto i : n)        //统计为m的个数. 小于m的跳过，大于m的除以m找值。
        {
          if (i < m)continue;
          cnt += i / m;
        }
        //ed
        //dbg(m);
        //dbg(cnt);
        if (cnt == k)return m;

        //特意加了这个来暂存二分里的有效值，因为此问题里cnt只能大不能小，所以对应的m就只能小不能大，在这个区间切换之前存下前一个有效值
        if (cnt > k)prev_valid = m;

        //如果cnt<k,说明m值太大导致可用的堆数太少，需要缩小m的值，所以这里是cnt<k.
        if (cnt < k) 
          r = m;
        else {
          l = m + 1;
        }
      }
      return -1;
      //把这个换成-1就行了，前提是... 前面的valid的部分被保存下来了。
    };
    int right = n.back();
    int res = binarySearch(1, right + 1);
    if (res == -1)
      res = prev_valid;
    return res;
  }
};
```


通过测试用例： 69 / 100  
输出： 658   
预期结果：659  
边界条件限制不当，明天继续。  
