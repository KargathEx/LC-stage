我讨厌二分，尤其是这种套了很多层，该怎么调试都得想半天的坑b.

先挂起来，不然今晚就全盯着它心烦了。

找点自己能打得过的攒攒成就感。
```cpp

class Solution {
  int issubsep(string s, string p, vi& deleted)
  {
    for (auto i : deleted)s[i] = '#';
    string s_;
    for (auto i : s)
      if (i != '#')s_ += i;
    D(s_);
    D(p);
    ed;
    return includes(all(s_), all(p));
  }
  int binarySearch(int l, int r, vi& n, string s, string p) //要找最大值，则满足条件就向右走，直到invalid,此时-1就是答案.
  {
    while (l < r) {
      int m = l + (r - l) / 2;
      vi cur(n.begin(), n.begin() + m); //取前k个数字.
      D(cur);
      if (issubsep(s, p, cur))  //debug的话要看哪些东西？
        l = m + 1;
      else
        r = m;
    }
    return l-1;
  }
public:
  int maximumRemovals(string s, string p, vector<int>& removable) {
    //k满足条件，越小越可能，越大越不可能。
    //故二分，最大为sz(),最小是0.
    //读取其元素，删除，然后判断p是否为s的子串。
    //include足矣判断子串。
    //如何模拟“删除”？
    //拆分左右再拼起来足矣。
    int l = 0, r = sz(removable);
    return binarySearch(l, r, removable, s, p);
  }
};

```
