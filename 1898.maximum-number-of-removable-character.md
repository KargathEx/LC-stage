我讨厌二分，尤其是这种套了很多层，该怎么调试都得想半天的坑b.  
https://leetcode.cn/problems/maximum-number-of-removable-characters/  

认真想了，二分的部分应该是一点问题都没有，还是不知道哪里错了。
对比了一下别人的做法，我的二分部分果然没错，那我就不懂了，到底错在哪里了？isSubSep()我也输出看了，执行过程跟我想的都一样啊..

别人的做法:
```cpp
class Solution {
public:
  int maximumRemovals(string s, string p, vector<int>& removable) {
    const int n = s.length();
    const int t = p.length();
    const int m = removable.size();
    int l = 0;
    int r = m + 1;
    vector<int> idx(n, INT_MAX);  //开这么大是要造反吗？
    for (int i = 0; i < m; ++i)
      idx[removable[i]] = i;  //value->index 还能这么玩...
    while (l < r) {
      int mid = l + (r - l) / 2;
      int j = 0;
      for (int i = 0; i < n && j < t; ++i)  //遍历p的每个位置, j < t 是为了，找够了也停？
        if (idx[i] >= mid && s[i] == p[j]) ++j;   //这个是在干嘛? 我觉得唯一可能diff的地方就是这里了.
      if (j == t) //条件判断等价于我的isSubSep().
        l = mid + 1;
      else
         r = mid;
    }
    // l is the smallest number s.t. p is no longer a subseq of s.
    return l - 1;
  }
};
```

我的写法:
```cpp

class Solution {
  //看了一圈只可能是这里的错了..
  int isSubSep(string s, string p, vi& deleted)
  {
    for (auto i : deleted)s[i] = '#'; //标记为删除，后面跳过这些.
    string s_;
    for (auto i : s) if (i != '#')s_ += i;
    //D(s_);
    //D(p);
    //ed;
    //D(s);
    //D(s_);
    return includes(all(s_), all(p)); //查询p是否为deleted之后的s的子串.
  }
  int binarySearch(int l, int r, vi& n, string s, string p) //要找最大值，则满足条件就向右走，直到invalid,此时-1就是答案.
  {
    while (l < r) {
      int m = l + (r - l) / 2;
      vi cur(n.begin(), n.begin() + m+1); //取前m个数字,+1因为传迭代器的ctor右边是开区间(构造拥有范围 [first, last) 内容的容器。)
      if (isSubSep(s, p, cur))  //为了求最大，应该在valid的时候挪left? 一般的取max的都什么样？ 441:cond true,挪左边
        l = m + 1;      //那我应该是没错的..
      else
        r = m;
    }
    return l - 1;
  }
public:
  int maximumRemovals(string s, string p, vector<int>& removable) {
    //k满足条件，越小越可能，越大越不可能。
    //首先这个，是这样吗？ 在“p 是 s 的一个 子序列”的前提下，删的越多应该越不可能.
    //但是这个未必成为线性关系..? 不是的，如果某次删除导致该有的某个元素被删了，那么之
    //后就都invalid了，所以满足 valid,valid,valid,invalid,invalid,invalid的情况
    int l = 0, r = sz(removable)+1;
    return binarySearch(l, r, removable, s, p);
  }
};
```
