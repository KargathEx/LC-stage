难得靠分析搞出来[第三题](https://leetcode.cn/contest/biweekly-contest-81/problems/maximum-xor-after-operations/)，然而还没入库没法存题解，先扔在这里。

分析了一波然后很简单的就做出来了，难得难得，我以为第三题会是什么彪形大汉...

3 XOR 2 XOR 4 XOR 2 = 7 
11	10	100	10
01 100 10
101 10
111
所以要求... 任何位置的1都是奇数个，这样对消之后结果是1，
任何位置 是什么意思？ 是最终结果的每一位，在每个数字里对应的位置。
那关于0呢？ 也要求有奇数个1. 就好了。

换句话说，每个位置都要求有奇数个1.
你的操作能带给你什么？
xor x,如果x是2^i 则xor x可以把任意位置的1改成0.
然后ni&ni_ 就可以把改掉的0写进去。

可以把任意位置的0换成1吗？ 这就要x的形式为..跟上面一样啊。
xor之后成了1，&的话未必能写进去..? 是的，所以不能。

于是我只能删掉1，而不能加上1.
如果把所有位置都累加起来，遇到1的就保留，假装删除过，遇到0就不管，是不是就能得到目标值了?
试试看吧。
那就是|运算了呗。
```cpp
class Solution {
public:
  int maximumXOR(vector<int>& n) {
    int res = 0;
    for (auto i : n)
      res |= i;
    return res;
  }
};
```

有空调真好啊，至少能正常思考了。
