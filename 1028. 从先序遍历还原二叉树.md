```cpp

class Solution {
  const int32_t TREE_NODE_BOUNDNARY = INT_MIN + 1;
  TreeNode* CTree(vector<int> vec)
  {
    size_t count = vec.size();
    vector<TreeNode*>treeArr(count);
    for (size_t i = 0; i < count; i++)
    {
      if (TREE_NODE_BOUNDNARY == vec[i]) {
        treeArr[i] = nullptr;
      }
      else {
        treeArr[i] = new TreeNode(vec[i]);	//Assign
      }
    }
    size_t curr = 1;
    for (size_t i = 0; i < count; i++)
    {
      if (!treeArr[i]) {
        continue;
      }
      if (curr < count) {
        treeArr[i]->left = treeArr[curr++];
      }
      if (curr < count) {
        treeArr[i]->right = treeArr[curr++];
      }
    }
    TreeNode* root = new TreeNode();
    root = treeArr[0];
    return root;
  }
public:
  TreeNode* recoverFromPreorder(string s) {
    //我觉得按照层序遍历的样子填充好数组，然后直接创建就行了吧！
    //收集-的个数来知道在第几层.. 之类的。
    //观察来的东西是，直接根据递增的-计数来顺序塞进即可。
    //pair sort不可行，因为value大小未定。
    //一次遍历，根据--的个数塞入不同的组里，最后合并所有的组，试试看吧。
    int elemCnt = count_if(begin(s), end(s), [](char ch) {return ch != '-'; });
    vector<int> pre;
    auto prev = s[0];
    int cnt = 0;
    int i = 0;
    vector<int> n;
    for (auto i : s)
    {
      if (i != '-')n.push_back(i - '0');
    }
    D(n);
    while (i < s.size())
    {
      while (s[i] == '-') {
        ++cnt;
        ++i;
      }
      if (cnt) pre.push_back(cnt);
      cnt = 0;
      ++i;
    }
    D(pre);
    int h = *max_element(begin(pre), end(pre));
    vector<vector<int>> group(h + 1);
    for (int i = 1; i <= h; ++i)
      for (int j = 0; j < pre.size(); ++j) //其实就差那么一点点，谁是padding来着?
        if (pre[j] == i)group[i].push_back(n[j + 1]);
    D(group); //我还需要正确处理空leaf的情况..
    vector<int> lo;
    lo.push_back(1);
    for (auto i : group) {
      if (i.empty())continue;
      for (auto j : i)
      {
        lo.push_back(j);
      }
    }
    D(lo);
    return CTree(lo);
  }
};
```

上述只通过第一个例子，对于非完全二叉树就不行了，我考虑不周。
todo:每个数字后面的--的相同长度都是成对的，不成对的就要面临审判！ 想想这个怎么加进去。
https://leetcode.cn/contest/weekly-contest-132/problems/recover-a-tree-from-preorder-traversal/
