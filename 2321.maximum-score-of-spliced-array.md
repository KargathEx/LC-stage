[link](https://leetcode.cn/contest/weekly-contest-299/problems/maximum-score-of-spliced-array/) 
给你两个下标从 **0** 开始的整数数组 `nums1` 和 `nums2` ，长度都是 `n` 。

你可以选择两个整数 `left` 和 `right` ，其中 `0 <= left <= right < n` ，接着 **交换** 两个子数组 `nums1[left...right]` 和 `nums2[left...right]` 。

- 例如，设 `nums1 = [1,2,3,4,5]` 和 `nums2 = [11,12,13,14,15]` ，整数选择 `left = 1` 和 `right = 2`，那么 `nums1` 会变为 `[1,***12\*,\*13\***,4,5]` 而 `nums2` 会变为 `[11,***2,3***,14,15]` 。

你可以选择执行上述操作 **一次** 或不执行任何操作。

数组的 **分数** 取 `sum(nums1)` 和 `sum(nums2)` 中的最大值，其中 `sum(arr)` 是数组 `arr` 中所有元素之和。

返回 **可能的最大分数** 。

**子数组** 是数组中连续的一个元素序列。`arr[left...right]` 表示子数组包含 `nums` 中下标 `left` 和 `right` 之间的元素**（含** 下标 `left` 和 `right` 对应元素**）**。

**示例 1：**

```
输入：nums1 = [60,60,60], nums2 = [10,90,10]
输出：210
解释：选择 left = 1 和 right = 1 ，得到 nums1 = [60,90,60] 和 nums2 = [10,60,10] 。
分数为 max(sum(nums1), sum(nums2)) = max(210, 80) = 210 。
```

**示例 2：**

```
输入：nums1 = [20,40,20,70,30], nums2 = [50,20,50,40,20]
输出：220
解释：选择 left = 3 和 right = 4 ，得到 nums1 = [20,40,20,40,20] 和 nums2 = [50,20,50,70,30] 。
分数为 max(sum(nums1), sum(nums2)) = max(140, 220) = 220 。
```

**示例 3：**

```
输入：nums1 = [7,11,13], nums2 = [1,1,1]
输出：31
解释：选择不交换任何子数组。
分数为 max(sum(nums1), sum(nums2)) = max(31, 3) = 31 。
```

 

**提示：**

- `n == nums1.length == nums2.length`
- `1 <= n <= 105`
- `1 <= nums1[i], nums2[i] <= 104`

### 思路

求出俩diff,在里面找最长子数组，塞进其中一个里面。  
然后反过来求另一个的，加进另一个原数组里。  
就代表了通过交换子数组能获得的变化量。  
然而连错都算不上..
扔出来是为了清空IDE,明天还有考试...   

```cpp

class Solution{
  //滑动窗口找最大子数组.
  int maxSubArray(vi& n)
  {
    vi dp(n.size(), 0);
    dp[0] = n[0];
    for (int i = 1; i < n.size(); ++i)
      dp[i] = max(dp[i - 1] + n[i], n[i]);  //这样不够，得存更多信息，最好是.. 没有最好.
    return dp.back();
  }
public:
  int maximumsSplicedArray(vector<int>& n1, vector<int>& n2) {
    //只能执行一次或者不执行。
    //  昨晚思路为，diff, 取max sub windows，附加到另一边。
    //  swap一下，取max sub windows, 附加到另一边，取最大值。
    //  事实上这样也确实够了！
    //开俩数组分别试试吧!
    int len = n1.size();
    auto sum1 = accumulate(all(n1), 0LL);
    auto sum2 = accumulate(all(n2), 0LL);
    if (sum1 < sum2) {
      swap(n1, n2), swap(sum1, sum2);
    };

    vi diff1(len, 0);
    for (int i = 0; i < len; ++i)
      diff1[i] = n1[i] - n2[i];
    vi diff2(len, 0);
    for (int i = 0; i < len; ++i)
      diff2[i] = n2[i] - n1[i];
    return max(maxSubArray(diff1) + sum1, maxSubArray(diff2) + sum2);
  }
};
```