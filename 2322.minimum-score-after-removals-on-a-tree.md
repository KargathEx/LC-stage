存在一棵无向连通树，树中有编号从 `0` 到 `n - 1` 的 `n` 个节点， 以及 `n - 1` 条边。

给你一个下标从 **0** 开始的整数数组 `nums` ，长度为 `n` ，其中 `nums[i]` 表示第 `i` 个节点的值。另给你一个二维整数数组 `edges` ，长度为 `n - 1` ，其中 `edges[i] = [ai, bi]` 表示树中存在一条位于节点 `ai` 和 `bi` 之间的边。

删除树中两条 **不同** 的边以形成三个连通组件。对于一种删除边方案，定义如下步骤以计算其分数：

1. 分别获取三个组件 **每个** 组件中所有节点值的异或值。
2. **最大** 异或值和 **最小** 异或值的 **差值** 就是这一种删除边方案的分数。

- 例如，三个组件的节点值分别是：`[4,5,7]`、`[1,9]` 和 `[3,3,3]` 。三个异或值分别是 `4 ^ 5 ^ 7 = 6`、`1 ^ 9 = 8` 和 `3 ^ 3 ^ 3 = 3` 。最大异或值是 `8` ，最小异或值是 `3` ，分数是 `8 - 3 = 5` 。

返回在给定树上执行任意删除边方案可能的 **最小** 分数。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2022/05/03/ex1drawio.png)

```
输入：nums = [1,5,5,4,11], edges = [[0,1],[1,2],[1,3],[3,4]]
输出：9
解释：上图展示了一种删除边方案。
- 第 1 个组件的节点是 [1,3,4] ，值是 [5,4,11] 。异或值是 5 ^ 4 ^ 11 = 10 。
- 第 2 个组件的节点是 [0] ，值是 [1] 。异或值是 1 = 1 。
- 第 3 个组件的节点是 [2] ，值是 [5] 。异或值是 5 = 5 。
分数是最大异或值和最小异或值的差值，10 - 1 = 9 。
可以证明不存在分数比 9 小的删除边方案。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2022/05/03/ex2drawio.png)

```
输入：nums = [5,5,2,4,4,2], edges = [[0,1],[1,2],[5,2],[4,3],[1,3]]
输出：0
解释：上图展示了一种删除边方案。
- 第 1 个组件的节点是 [3,4] ，值是 [4,4] 。异或值是 4 ^ 4 = 0 。
- 第 2 个组件的节点是 [1,0] ，值是 [5,5] 。异或值是 5 ^ 5 = 0 。
- 第 3 个组件的节点是 [2,5] ，值是 [2,2] 。异或值是 2 ^ 2 = 0 。
分数是最大异或值和最小异或值的差值，0 - 0 = 0 。
无法获得比 0 更小的分数 0 。
```

**提示：**

- `n == nums.length`
- `3 <= n <= 1000`
- `1 <= nums[i] <= 108`
- `edges.length == n - 1`
- `edges[i].length == 2`
- `0 <= ai, bi < n`
- `ai != bi`
- `edges` 表示一棵有效的树



### 思路

无向图，删除两条边形成三个连通分量,对每个连通分量里面所有节点xor为结果。  
这些结果里 max - min为分数。  
要求最小分数，也就是max min尽可能接近。  
节点数量1000.可以用n ^ 2的。  
尝试删掉每一条边，dfs来计算xor结果，如果删掉某条边之后恰好有三个连通分量，则计算上述来更新结果。  

```cpp
#define ice
#ifdef ice
typedef long long ll;
typedef vector<int> vi;
typedef vector<vi> vii;
typedef vector<string> vs;
typedef vector<vs> vss;
#define all(c) c.begin(), c.end()
#define rall(c) c.rbegin(), c.rend()
//const int dx[4]{ 1,0,-1,0 }, dy[4]{ 0,1,0,-1 };
#define sz(a) int((a).size())
#define pb push_back
template<typename T> void un(T& n) { sort(all(n)); n.erase(std::unique(n.begin(), n.end()), n.end()); }
template<typename T>set<typename T::value_type> to_set(T t) { return set(t.begin(), t.end()); }
template<typename T>vector<typename T::value_type> set_to(T input) { vector<typename T::value_type> output; std::copy(input.begin(), input.end(), std::back_inserter(output)); return output; }
vector<int> get_insect(vector<int>n1, vector<int> n2) { vector<int> res; set_intersection(all(n1), all(n2), inserter(res, res.end())); return res; }
template<typename T>auto clear(queue<T>& q) { std::queue<T>empty; std::swap(q, empty); }
template<class T> using pqg = priority_queue<T, vector<T>, greater<T>>;
vector<string> split(string s, string delimiter = " ") {
  std::stringstream stringStream(s);
  std::string line;
  vector<string> wordVector;
  while (std::getline(stringStream, line))
  {
    std::size_t prev = 0, pos;
    while ((pos = line.find_first_of(delimiter, prev)) != std::string::npos)
    {
      if (pos > prev)
        wordVector.push_back(line.substr(prev, pos - prev));
      prev = pos + 1;
    }
    if (prev < line.length())
      wordVector.push_back(line.substr(prev, std::string::npos));
  }
  return wordVector;
}
#define D(x) cout << #x << " : " << x << endl;
#define ed cout << endl;
//#define  sw cout<<res<<endl<<l<<" "<<r<<endl<<endl; //滑动窗口debug用。
//#define rt  return res;

#endif
//#define D(x);


class Solution {
  int dfs(vii& g, int x, int banX, int banY, vi& visited, vi& n)
  {
    int res = n[x];
    visited[x] = 1;
    for (auto k : g[x]) {
      if (visited[k])continue;
      if ((x == banX, k == banY) || (k == banX, x == banY))continue;  //两条边都删掉.
      visited[k] = 1;
      res ^= dfs(g, k, banX, banY, visited, n);
    }
    //D(visited);
    return res;
  }
public:
  int minimumScore(vector<int>& n, vector<vector<int>>& graph) {
    int len = n.size();
    int res = INT_MAX;
    vector<vector<int>> adj(len);
    for (auto& edge : graph) {
      adj[edge[0]].push_back(edge[1]);
      adj[edge[1]].push_back(edge[0]);
    }
    for (int i = 0; i < adj.size(); ++i)  //尝试删掉每一条边
      for (auto j : adj[i])
      {
        vi visited(len, 0);
        vector<int> temp;
        for (int l = 0; l < len; ++l) {
          if (!visited[l]) {
            auto ret = dfs(adj, l, i, j, visited, n);
            temp.push_back(ret);
          }
        }
        D(temp);
        if (temp.size() == 3) {
          auto [Min, Max] = minmax_element(all(temp));
          int diff = *Max - *Min;
          D(res);
          D(diff);
          ed;
          res = min(res, diff);
        }
        fill(all(visited), 0);
        temp.clear();
      }
    return res;
  }
};
