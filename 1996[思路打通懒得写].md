https://leetcode.cn/classic/problems/the-number-of-weak-characters-in-the-game/description/
题目链接

问题是对于1,1 1,2 2,1 2,2 
该怎么处理，实际上应该是1，但是我的实现输出2.
我的目标是sorted x 之后，在处理y的时候对于每个值，把它前面比自己小的都弹出来并且累加计数。
会遇到问题"y值比它小的x值可能与他相同"，但是又不能简单的将这种值跳过，或者..
那，直接留着不管就行了对吧？是的！

其实可以这么理解，有二维图形，要求找到被其他图形包含的那些。
也就是，
可是那个是对一个二分对另一个遍历，这个我要对谁二分？ 每个值都是二分目标啊..

对每个都for循环，只往前看不往后看，前面的只要y值与自己齐了，就跳过，否则删掉。
删掉之后的就不需要再管了对吧，是的。
那如果我从后往前走 ，遇到y比自己大或相等的就留下，遇到比自己小的就删掉，可行吧？
可行啊。
怎么个留下？
塞进单调栈里，？
首先注意一点，因为前面的x都更小，所以要想留下一定是看y值。
如果x相同就留下。
如果x更小但是y更大也留下,留下的时候之前的x不能删，因为它依旧可以用来屠杀x值比当前y更大的x更大的值，是吗？
我觉得不是，因为再往前的x只会比当前的y更小，但也可能相同，这样的话..
是有可能被当前x杀掉而前一个y杀不掉(因为前一个y就算y更大，x总是相同的)。

之后再往前，如果遇到y值很大的，就看当前的y值是否比他大，是的话扔掉它(即被淘汰)，否则就扔掉自己并且请她进来。

总结一下[2]，从后往前走，x排序。
遇到x与自己相同的就看y值，如果小于则无视，等于的话无视，大于的话换掉。
遇到x比自己小的就看y值，如果小于依旧是杀掉，等于的话无视(因为不构成影响),大于的话保留。
	保留的意义在于，这样再往前遇到更小的数字的时候，假设x已经是更小了，则当前的y可以比后面的y更有效地杀伤。

那么你在什么时候执行杀人命令呢？
	什么时候弹栈呢？
		在遇到新元素的时候，满足什么条件的时候才肯弹栈呢？

		对于下面的例子，我觉得...

		前面写的内容里，我已经尽量保留有特色的数字了，等等。 我说了是要无视的，也就是说[1]这里不该允许它入栈
这样怎么样？
试试看吧，对于例子
[[1,1,],[1,2,][2,1],[2,2]]
已经排序了，从后往前看y即可。
st :2
前一个x相同，y属于小于等于，没有留的必要	st: 2
前一个是2，对于当前栈顶来说也是小于等于，不留， st:2
前一个是1，双小的数字，cnt++.
最后是1，蛮好。

对于
[[5,5],[6,3],[3,6]]
又如何呢?
排序之后是
[[3,6],[5,5],[6,3]]
st:3.
前一个，入栈 5,3
前一个，入栈 6 5 3
于是为0

其他的呢？
[[1,5],[10,4],[4,3]]
sorted: 
[[1,5],[4,3],[10,4]]

st:4
st:4 cnt+1

1

[[1,7],[1,7],[7,5],[9,6],[10,10],[10,6],[4,5],[9,5]]
对于这个呢？
我还是让程序来跑吧？
懒得写，手动画~
[[1, 7], [1, 7], [4, 5], [7, 5], [9, 5], [9, 6], [10, 6], [10, 10]]
st: 
10

6

没问题了。
接下来只需要把[2]处的逻辑写成代码即可。
这份光荣的任务就交给你了！

不行，我一定得骗你学会写代码，这样以后我就只负责关键思路，你来写实现了。
这样周赛的时候我就有更多的时间想思路哈哈哈，活体外挂，编码自动机



## append:
### 垃圾代码1

```cpp
//#define D(x);
class Solution {
public:
  int numberOfWeakCharacters(vector<vector<int>>& n) {
    //sort by x，y变成无序,在其上执行单调栈.
    //因为x是递增的，所以y比自己小的都存进来，遇到比当前大的就开始弹栈，因为x已经是递增了，所以y也比栈顶大的话就一定是强角色，弹出所有双小的，直到遇到y比当前大的(或者相等的)就停下。
    //然后把新元素塞进来，当前依旧满足 ak 递增，df递减的顺序，然后继续往后走。
    //最后因为已经不可能有更大的元素加进来了，所以开始清算，去除st末尾最大的元素依次与递减栈前i-1个元素比较，吗？ 应该是取出末尾的吧?
    sort(all(n));
    D(n);
    vi st;  //存index,但是要求..
    int cnt = 0;
    for (int i = 0; i < n.size(); ++i)
    {
      while (!st.empty() && n[i][1] > n[st.back()][1] && n[i][0] > n[st.back()][0]) {
        //如果在一个相等的情况下另一个是弱序，就只弹出不计数？
        //这样可能存在问题，后面万一有很大的元素呢？
        //如果直到最后都没有才执行这个，好的。
        st.pop_back();
        ++cnt;
      }
      st.push_back(i);
    }

    D(st);
    int x = INT_MIN;
    int y = INT_MIN;
    for (auto i : n) {
      x = max(x, i[0]);
      y = max(y, i[1]);
    }
    if (!st.empty()) {
      for (int j = 0; j < st.size(); ++j) //我得要求它是最大值之一，否则会有多余。
      {
        if (n[j][0] != x && n[j][1] != y)continue;  //这样过滤是不行的，应该把有错的都塞进set来去重..? 万一有重复的呢?
        //我服了..
        vector<int> stt = st;
        auto i = j; //末尾的元素的y值只会相等或者更小，相等的情况为 1,1 1,2  2,1 2,2
        //这里取出最后一个来向前压，满足条件。
        //但是这样太刻意了，如果末尾的是500,500 , ... 前面有2,2 呢？ 是不是该在while中update一下i的值?
        //如果存在这个值的话，它会在哪里出现?
        //我觉得每次都update就挺好~
        //不行，会导致 1,1 遇到的不是2,2 而是2,1 这样就跪了.
        D(n[i]);
        //那难道对每个数字都执行一遍吗?
        while (!stt.empty())
        {
          if (n[i][0] > n[stt.back()][0] && n[i][1] > n[stt.back()][1]) {
            D(n[stt.back()]);
            ++cnt;
          }
          stt.pop_back();
        }
      }
    }
    return cnt;
  }
};
```

### 垃圾代码2
```cpp
//融合之后,依旧会撞到63 36的问题,所以找全局max x-y是不可能的.
class Solution_e {
public:
  int numberOfWeakCharacters(vector<vector<int>>& n) {
    sort(all(n));
    int x = n.back()[0];
    int y = INT_MIN;
    for (int i = n.size() - 1; i >= 0; --i)
    {
      if (n[i][0] < x)break;
      if (n[i][0] == x)
        y = max(y, n[i][1]);
    }
    //然后找所有的.
    int c = 0;
    for (int i = 0; i < n.size(); ++i)
    {
      if (n[i][0] < x && n[i][1] < y)
        ++c;
    }
    return c;
  }
};
```